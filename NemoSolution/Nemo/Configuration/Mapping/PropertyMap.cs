using Nemo.Attributes;
using Nemo.Id;
using Nemo.Reflection;
using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

namespace Nemo.Configuration.Mapping
{
    public class PropertyMap<T> : IPropertyMap
    {
        private readonly ReflectedProperty _property;
        private readonly Expression<Func<T>> _selector;
        private bool _not;

        internal PropertyMap(Expression<Func<T>> selector, bool not = false)
        {
            _selector = selector;
            _not = not;

            var property = (PropertyInfo)((MemberExpression)selector.Body).Member;
            _property = new ReflectedProperty(property, readAttributes: false);
        }

        public PropertyMap<T> Not()
        {
            return new PropertyMap<T>(_selector, true);
        }

        public PropertyMap<T> PrimaryKey(int position = 0)
        {
            _property.IsPrimaryKey = _not ? false : true;
            _property.KeyPosition = position;
            _not = false;
            return this;
        }

        public PropertyMap<T> CacheKey()
        {
            _property.IsCacheKey = _not ? false : true;
            _not = false;
            return this;
        }

        public PropertyMap<T> Generated(Type generator = null)
        {
            if (generator != null && typeof(IIdGenerator).IsAssignableFrom(generator))
            {
                _property.Generator = generator;
                _property.IsAutoGenerated = false;
            }
            else
            {
                _property.Generator = null;
                _property.IsAutoGenerated = _not ? false : true;
            }
            _not = false;
            return this;
        }

        public PropertyMap<T> References<U>(int position = 0)
            where U : class, IBusinessObject
        {
            _property.Parent = typeof(U);
            _property.RefPosition = position;
            _not = false;
            return this;
        }

        public PropertyMap<T> Parameter(string name, ParameterDirection direction = ParameterDirection.Input)
        {
            _property.ParameterName = name;
            _property.Direction = direction;
            _not = false;
            return this;
        }

        public PropertyMap<T> Persistent()
        {
            _property.IsPersistent = _not ? false : true;
            _not = false;
            return this;
        }

        public PropertyMap<T> Selectable()
        {
            _property.IsSelectable = _not ? false : true;
            _not = false;
            return this;
        }

        public PropertyMap<T> Serializable()
        {
            _property.IsSerializable = _not ? false : true;
            _not = false;
            return this;
        }

        public PropertyMap<T> Sorted<U>()
            where U : class, IComparer<T>
        {
            if (_property.IsListInterface)
            {
                _property.Sorted = new SortedAttribute { ComparerType = typeof(U) };
            }
            _not = false;
            return this;
        }

        public PropertyMap<T> Sorted()
        {
            if (_property.IsListInterface)
            {
                _property.Sorted = new SortedAttribute();
            }
            _not = false;
            return this;
        }

        public PropertyMap<T> Distinct<U>()
            where U : class, IEqualityComparer<T>
        {
            if (_property.IsListInterface)
            {
                _property.Distinct = new DistinctAttribute { EqualityComparerType = typeof(U) };
            }
            _not = false;
            return this;
        }

        public PropertyMap<T> Distinct()
        {
            if (_property.IsListInterface)
            {
                _property.Distinct = new DistinctAttribute();
            }
            _not = false;
            return this;
        }

        public PropertyMap<T> Column(string name)
        {
            _property.MappedColumnName = name;
            _not = false;
            return this;
        }

        public PropertyMap<T> SourceProperty(string name)
        {
            _property.MappedPropertyName = name;
            _not = false;
            return this;
        }

        ReflectedProperty IPropertyMap.Property
        {
            get
            {
                return _property;
            }
        }
    }
}
